!<arch>
__.PKGDEF       0           0     0     644     18876     `
go object linux arm devel +70499e5fbe5b Fri Feb 21 14:35:54 2014 -0800 X:precisestack

$$
package ecdsa
	import runtime "runtime"
	import io "io"
	import elliptic "crypto/elliptic"
	import big "math/big"
	type @"math/big".Word uintptr
	type @"math/big".divisor struct { @"math/big".bbb @"math/big".nat; @"math/big".nbits int; @"math/big".ndigits int }
	import rand "math/rand" // indirect
	type @"math/rand".Source interface { Int63() (? int64); Seed(@"math/rand".seed int64) }
	type @"math/rand".Rand struct { @"math/rand".src @"math/rand".Source }
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) ExpFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Float32 () (? float32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Float64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int () (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int31 () (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int31n (@"math/rand".nÂ·3 int32) (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int63 () (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int63n (@"math/rand".nÂ·3 int64) (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Intn (@"math/rand".nÂ·3 int) (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) NormFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Perm (@"math/rand".nÂ·3 int) (? []int)
	func (@"math/rand".rÂ·1 *@"math/rand".Rand) Seed (@"math/rand".seedÂ·2 int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Uint32 () (? uint32)
	type @"io".RuneScanner interface { ReadRune() (@"io".r rune, @"io".size int, @"io".err error); UnreadRune() (? error) }
	type @"math/big".nat []@"math/big".Word
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".add (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".and (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".andNot (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x0") @"math/big".bit (@"math/big".iÂ·3 uint) (? uint) { var @"math/big".jÂ·4 int; ; @"math/big".jÂ·4 = int(@"math/big".iÂ·3 / 0x20); if @"math/big".jÂ·4 >= len(@"math/big".zÂ·2) { return 0x0 }; return uint(@"math/big".zÂ·2[@"math/big".jÂ·4] >> (@"math/big".iÂ·3 % 0x20) & @"math/big".Word(0x1)) }
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".bitLen () (? int)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x0") @"math/big".bytes (@"math/big".bufÂ·3 []byte "esc:0x0") (@"math/big".iÂ·1 int)
	func (@"math/big".zÂ·1 @"math/big".nat "esc:0x0") @"math/big".clear ()
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".cmp (@"math/big".yÂ·3 @"math/big".nat "esc:0x0") (@"math/big".rÂ·1 int)
	func (@"math/big".qÂ·1 @"math/big".nat) @"math/big".convertWords (@"math/big".sÂ·2 []byte "esc:0x0", @"math/big".charsetÂ·3 string "esc:0x0", @"math/big".bÂ·4 @"math/big".Word, @"math/big".ndigitsÂ·5 int, @"math/big".bbÂ·6 @"math/big".Word, @"math/big".tableÂ·7 []@"math/big".divisor "esc:0x0")
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".decimalString () (? string)
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".div (@"math/big".z2Â·4 @"math/big".nat, @"math/big".uÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat "esc:0x1") @"math/big".divLarge (@"math/big".uÂ·4 @"math/big".nat, @"math/big".uInÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".divW (@"math/big".xÂ·4 @"math/big".nat, @"math/big".yÂ·5 @"math/big".Word) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNN (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x0", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNNWindowed (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x0", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expWW (@"math/big".xÂ·3 @"math/big".Word, @"math/big".yÂ·4 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".make (@"math/big".nÂ·3 int) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat) @"math/big".modW (@"math/big".dÂ·3 @"math/big".Word) (@"math/big".rÂ·1 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mul (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulAddWW (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".Word, @"math/big".rÂ·5 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulRange (@"math/big".aÂ·3 uint64, @"math/big".bÂ·4 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".norm () (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".or (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".nÂ·2 @"math/big".nat) @"math/big".probablyPrime (@"math/big".repsÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".random (@"math/big".randÂ·3 *@"math/rand".Rand, @"math/big".limitÂ·4 @"math/big".nat "esc:0x0", @"math/big".nÂ·5 int) (? @"math/big".nat)
	func (@"math/big".zÂ·4 @"math/big".nat) @"math/big".scan (@"math/big".rÂ·5 @"io".RuneScanner, @"math/big".baseÂ·6 int) (? @"math/big".nat, ? int, ? error)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".set (@"math/big".xÂ·3 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".setBit (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".iÂ·4 uint, @"math/big".bÂ·5 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".setBytes (@"math/big".bufÂ·3 []byte "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".setUint64 (@"math/big".xÂ·3 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".setWord (@"math/big".xÂ·3 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shl (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shr (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".string (@"math/big".charsetÂ·3 string "esc:0x0") (? string)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".sub (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".trailingZeroBits () (? uint)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".xor (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	import fmt "fmt" // indirect
	type @"fmt".State interface { Flag(@"fmt".c int) (? bool); Precision() (@"fmt".prec int, @"fmt".ok bool); Width() (@"fmt".wid int, @"fmt".ok bool); Write(@"fmt".b []byte) (@"fmt".ret int, @"fmt".err error) }
	type @"fmt".ScanState interface { Read(@"fmt".buf []byte) (@"fmt".n int, @"fmt".err error); ReadRune() (@"fmt".r rune, @"fmt".size int, @"fmt".err error); SkipSpace(); Token(@"fmt".skipSpace bool, @"fmt".f func(? rune) (? bool)) (@"fmt".token []byte, @"fmt".err error); UnreadRune() (? error); Width() (@"fmt".wid int, @"fmt".ok bool) }
	type @"math/big".Int struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
	func (@"math/big".zÂ·2 *@"math/big".Int) Abs (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Add (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) And (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) AndNot (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Binomial (@"math/big".nÂ·3 int64, @"math/big".kÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int) Bit (@"math/big".iÂ·3 int) (? uint)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") BitLen () (? int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Bits () (? []@"math/big".Word) { return @"math/big".xÂ·2.@"math/big".abs }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Bytes () (? []byte)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Cmp (@"math/big".yÂ·3 *@"math/big".Int "esc:0x0") (@"math/big".rÂ·1 int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Div (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) DivMod (@"math/big".xÂ·4 *@"math/big".Int, @"math/big".yÂ·5 *@"math/big".Int, @"math/big".mÂ·6 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Exp (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int "esc:0x0", @"math/big".mÂ·5 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·1 *@"math/big".Int "esc:0x0") Format (@"math/big".sÂ·2 @"fmt".State, @"math/big".chÂ·3 rune)
	func (@"math/big".zÂ·2 *@"math/big".Int) GCD (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int, @"math/big".aÂ·5 *@"math/big".Int, @"math/big".bÂ·6 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) GobDecode (@"math/big".bufÂ·3 []byte "esc:0x0") (? error)
	func (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") GobEncode () (? []byte, ? error)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Int64 () (? int64)
	func (@"math/big".zÂ·2 *@"math/big".Int) Lsh (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x0") MarshalJSON () (? []byte, ? error)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x0") MarshalText () (@"math/big".textÂ·1 []byte, @"math/big".errÂ·2 error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Mod (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) ModInverse (@"math/big".gÂ·3 *@"math/big".Int, @"math/big".pÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Mul (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) MulRange (@"math/big".aÂ·3 int64, @"math/big".bÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Neg (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Not (@"math/big".xÂ·3 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Or (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int) ProbablyPrime (@"math/big".nÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int) Quo (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) QuoRem (@"math/big".xÂ·4 *@"math/big".Int, @"math/big".yÂ·5 *@"math/big".Int, @"math/big".rÂ·6 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rand (@"math/big".rndÂ·3 *@"math/rand".Rand, @"math/big".nÂ·4 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rem (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rsh (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Scan (@"math/big".sÂ·3 @"fmt".ScanState, @"math/big".chÂ·4 rune) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Set (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetBit (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".iÂ·4 int, @"math/big".bÂ·5 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1") SetBits (@"math/big".absÂ·3 []@"math/big".Word) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetBytes (@"math/big".bufÂ·3 []byte "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetInt64 (@"math/big".xÂ·3 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) SetString (@"math/big".sÂ·4 string, @"math/big".baseÂ·5 int) (? *@"math/big".Int, ? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetUint64 (@"math/big".xÂ·3 uint64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Sign () (? int) { if len(@"math/big".xÂ·2.@"math/big".abs) == 0x0 { return 0x0 }; if @"math/big".xÂ·2.@"math/big".neg { return -0x1 }; return 0x1 }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") String () (? string)
	func (@"math/big".zÂ·2 *@"math/big".Int) Sub (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Uint64 () (? uint64) { if len(@"math/big".xÂ·2.@"math/big".abs) == 0x0 { return 0x0 }; var @"math/big".vÂ·3 uint64; ; @"math/big".vÂ·3 = uint64(@"math/big".xÂ·2.@"math/big".abs[0x0]); if true && len(@"math/big".xÂ·2.@"math/big".abs) > 0x1 { @"math/big".vÂ·3 |= uint64(@"math/big".xÂ·2.@"math/big".abs[0x1]) << 0x20 }; return @"math/big".vÂ·3 }
	func (@"math/big".zÂ·2 *@"math/big".Int) UnmarshalJSON (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) UnmarshalText (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Xor (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) @"math/big".binaryGCD (@"math/big".aÂ·3 *@"math/big".Int, @"math/big".bÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·4 *@"math/big".Int) @"math/big".scan (@"math/big".rÂ·5 @"io".RuneScanner, @"math/big".baseÂ·6 int) (? *@"math/big".Int, ? int, ? error)
	type @"crypto/elliptic".CurveParams struct { P *@"math/big".Int; N *@"math/big".Int; B *@"math/big".Int; Gx *@"math/big".Int; Gy *@"math/big".Int; BitSize int }
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) Add (@"crypto/elliptic".x1Â·4 *@"math/big".Int, @"crypto/elliptic".y1Â·5 *@"math/big".Int, @"crypto/elliptic".x2Â·6 *@"math/big".Int, @"crypto/elliptic".y2Â·7 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) Double (@"crypto/elliptic".x1Â·4 *@"math/big".Int, @"crypto/elliptic".y1Â·5 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·2 *@"crypto/elliptic".CurveParams) IsOnCurve (@"crypto/elliptic".xÂ·3 *@"math/big".Int, @"crypto/elliptic".yÂ·4 *@"math/big".Int) (? bool)
	func (@"crypto/elliptic".curveÂ·2 *@"crypto/elliptic".CurveParams "esc:0x1") Params () (? *@"crypto/elliptic".CurveParams) { return @"crypto/elliptic".curveÂ·2 }
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) ScalarBaseMult (@"crypto/elliptic".kÂ·4 []byte "esc:0x0") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) ScalarMult (@"crypto/elliptic".BxÂ·4 *@"math/big".Int, @"crypto/elliptic".ByÂ·5 *@"math/big".Int, @"crypto/elliptic".kÂ·6 []byte "esc:0x0") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·4 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".addJacobian (@"crypto/elliptic".x1Â·5 *@"math/big".Int, @"crypto/elliptic".y1Â·6 *@"math/big".Int, @"crypto/elliptic".z1Â·7 *@"math/big".Int, @"crypto/elliptic".x2Â·8 *@"math/big".Int, @"crypto/elliptic".y2Â·9 *@"math/big".Int, @"crypto/elliptic".z2Â·10 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".affineFromJacobian (@"crypto/elliptic".xÂ·4 *@"math/big".Int, @"crypto/elliptic".yÂ·5 *@"math/big".Int, @"crypto/elliptic".zÂ·6 *@"math/big".Int) (@"crypto/elliptic".xOutÂ·1 *@"math/big".Int, @"crypto/elliptic".yOutÂ·2 *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·4 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".doubleJacobian (@"crypto/elliptic".xÂ·5 *@"math/big".Int, @"crypto/elliptic".yÂ·6 *@"math/big".Int, @"crypto/elliptic".zÂ·7 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	type @"crypto/elliptic".Curve interface { Add(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".x2 *@"math/big".Int, @"crypto/elliptic".y2 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); Double(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); IsOnCurve(@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) (? bool); Params() (? *@"crypto/elliptic".CurveParams); ScalarBaseMult(@"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); ScalarMult(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) }
	type @"".PublicKey struct { ? @"crypto/elliptic".Curve; X *@"math/big".Int; Y *@"math/big".Int }
	type @"".PrivateKey struct { ? @"".PublicKey; D *@"math/big".Int }
	type @"io".Reader interface { Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	func @"".GenerateKey (@"".cÂ·3 @"crypto/elliptic".Curve, @"".randÂ·4 @"io".Reader) (@"".privÂ·1 *@"".PrivateKey, @"".errÂ·2 error)
	func @"".Sign (@"".randÂ·4 @"io".Reader, @"".privÂ·5 *@"".PrivateKey, @"".hashÂ·6 []byte "esc:0x0") (@"".rÂ·1 *@"math/big".Int, @"".sÂ·2 *@"math/big".Int, @"".errÂ·3 error)
	func @"".Verify (@"".pubÂ·2 *@"".PublicKey, @"".hashÂ·3 []byte "esc:0x0", @"".rÂ·4 *@"math/big".Int, @"".sÂ·5 *@"math/big".Int) (? bool)
	func @"".init ()

$$
_go_.5          0           0     0     644     76073     `
go object linux arm devel +70499e5fbe5b Fri Feb 21 14:35:54 2014 -0800 X:precisestack

!
  go13ld"crypto/elliptic.aio.amath/big.a ş&"".randFieldElement  ¨  ¨ šå ]á< “  “0 ‘   ›øÿÿš<à-å   ã,â â ä Ráüÿÿ   ã   ãT åX å   ãT åX å   ãP å@ âåå  å  å0ÿ/á å, å’åÁ á  á €àÀ á@€â,Ÿå åÄ/ á@å åÄ? á áP á  á@å0å   ë â @å0åå  áH å åL å å0@å@å40å0å8åå   ë åT å  åX åT å  Pã   
<ğä  Ÿå å   ë å å0 å å4 å å8 å å   ë åP åh Ÿå å   ë å å, åååL°Ÿå  ›å å   ëP0å å0å0å å   ëP å å å°Ÿå  ›å å   ë<ğäşÿÿê            (^ƒ€€À "runtime.morestack   €^ƒ€€À "runtime.makeslice   €^ƒ€€À io.ReadFull   Ø^ƒ€€À runtime.new    ^ƒ€€À 0math/big.(*Int).SetBytes   È^ƒ€€À runtime.new   ^ƒ€€À &math/big.(*Int).Sub   À^ƒ€€À &math/big.(*Int).Mod   ø^ƒ€€À &math/big.(*Int).Add   .  type.[]uint8   ˜.  "type.math/big.Int    .  "".one   8p"".autotmp_0003  type.int "".autotmp_0002  $type.*math/big.Int "".b type.[]uint8 "".params Btype.*crypto/elliptic.CurveParams "".err (type.error "".k  $type.*math/big.Int "".rand type.io.Reader "".c  4type.crypto/elliptic.Curve 
xm u .L & BA * 		     "".gcargsÂ·0 "".gclocalsÂ·1     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş"".GenerateKey  è  è šå ]á$ “  “0 ‘   ›øÿÿš$à-å   ã â â ä Ráüÿÿ   ã   ã< å@ å   ã< å@ å   ã8 å( å å, å å0 å å4 å å   ë å  å å< å å@ å< å  Pã   
$ğä€ Ÿå å   ë 0å å(å ‚å,å‚å8 å á0‚å0å   ë â @å0å å@å0å å( âåå  å$ å0ÿ/á8 åå‚åå‚å$ğäşÿÿê    
(^ƒ€€À "runtime.morestack   ø^ƒ€€À &"".randFieldElement   à^ƒ€€À runtime.new   ¸^ƒ€€À *math/big.(*Int).Bytes   à.  $type."".PrivateKey   8@
"".k $type.*math/big.Int "".err (type.error "".priv  &type.*"".PrivateKey "".rand type.io.Reader "".c  4type.crypto/elliptic.Curve 
HE M &l  ,21  	     "".gcargsÂ·2 "".gclocalsÂ·3     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş"".hashToInt  ğ  ğ šå ]á, “  “0 ‘   ›øÿÿš,à-å   ã(â â ä Ráüÿÿ   ã< âåå  å  å0ÿ/á å’åå   ë å å ‚âÂ á  á €àÀ1 á4@å á  á Tá  Ú80åP á@ á á Sá  *   ëı¼ú÷0@å0@å4 å80åh Ÿå å   ë å å0 å å4 å å8 å å   ë0å4 å€ áå @à  Rã  Ú0å(0å0å å   ë(0åD0å,ğäşÿÿê    (^ƒ€€À "runtime.morestack   À^ƒ€€À ,math/big.(*Int).BitLen   Ø^ƒ€€À $runtime.panicslice   ˜^ƒ€€À runtime.new   à^ƒ€€À 0math/big.(*Int).SetBytes   À^ƒ€€À &math/big.(*Int).Rsh   è.  "type.math/big.Int   0P"".autotmp_0014  type.int "".autotmp_0011  type.int "".ret $type.*math/big.Int "".orderBits 'type.int "".~r2 ($type.*math/big.Int "".c 4type.crypto/elliptic.Curve "".hash  type.[]uint8 
XF N ,’    	     "".gcargsÂ·4 "".gclocalsÂ·5     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş"".Sign  Ğ  Ğ šå ]á@ “(  “0 ‘   ›øÿÿš@à-å   ã â  â ä Ráüÿÿ   ã   ã   ãd åh å   ãd åh å   ã` å   ãL å  Pã  € å0åå4å0 âåå  å  å0ÿ/á å’å,å   ã   ã0 å å4 å åD å åH å å   ë å$ å åd å åh åd å  Pã  
   ã\ å@ğäÜŸå å   ë å å$ å å, å å   ë å  å$ å å   ë â @å0å åL å  Pã  € å8åå<å@å0å å8 âåå  å$ å0ÿ/á å å\ å å, å å   ë\å   ã ‘å  PãA     ã  Rã¸ÿÿ
P å åT å åX å å0 å å4 å å   ë å( åà Ÿå å   ë å åL ååå\ å å   ë å å` å å( å å   ë` å å å  å å   ë` å å å, å å   ë`å   ã ‘å  Pã     ã  Rã…ÿÿ
@ğäĞ Ñá  Pã  
  àã  Rã~ÿÿ
@ğä  ã  Rãzÿÿ
@ğäĞ Ñá  Pã  
  àã¹ÿÿê  ã·ÿÿêşÿÿê    (^ƒ€€À "runtime.morestack   ˜^ƒ€€À &"".randFieldElement   ^ƒ€€À runtime.new   È^ƒ€€À 4math/big.(*Int).ModInverse   ğ^ƒ€€À *math/big.(*Int).Bytes   È^ƒ€€À &math/big.(*Int).Mod   à^ƒ€€À "".hashToInt   ˆ^ƒ€€À runtime.new   È^ƒ€€À &math/big.(*Int).Mul   €	^ƒ€€À &math/big.(*Int).Add   °	^ƒ€€À &math/big.(*Int).Mul   à	^ƒ€€À &math/big.(*Int).Mod   È.  "type.math/big.Int   Px"".autotmp_0024  $type.*math/big.Int "".autotmp_0023  $type.*math/big.Int "".e /$type.*math/big.Int "".kInv ?$type.*math/big.Int "".k 7$type.*math/big.Int "".N '$type.*math/big.Int "".c 4type.crypto/elliptic.Curve "".err @type.error "".s 8$type.*math/big.Int "".r 0$type.*math/big.Int "".hash type.[]uint8 "".priv &type.*"".PrivateKey "".rand  type.io.Reader €² º d¸	

	
	
	 & %218 : %     "".gcargsÂ·6 "".gclocalsÂ·7     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş"".Verify       šå ]áT “  “0 ‘   ›øÿÿšTà-å   ã$â0 â ä Ráüÿÿ   ãX å  Pã  € åLååPåL âåå  å  å0ÿ/áh0å å@å   ã “å  PãÇ     ã  Rãº  
lå   ã ‘å  Pã¸     ã  Rã²  
0åH@å@å   ë å  Rã¨  ªl å åH å å   ë å  Rã   ª\ å å` å åd å åL å åP å å   ë åD åœŸå å   ë å ål å åH å å   ëD0å å0å0å8 å å   ë å å@ å åH å å   ë8 å åh å å å   ë å å< å åH å å   ë@ å å   ë â @å0å å@å0å åL âåå  å$ å0ÿ/á å0 å å$ å< å å   ëXPå â @å0å å•åå•åå@å0å åL âåå  å( å0ÿ/á0å  å0 å å$ å å0å åL âåå  å å0ÿ/áå@å   ã0 á ‘å  Pã)     ã  Rã
     ã á ”å  Pã     ã  Rã     ãp ÍåTğä0å40å0åH å å   ë4 å åh å å   ë å  Pã  
   ãp ÍåTğä  ãp ÍåTğä áĞ Ôá  Pã  
  àãàÿÿê  ãŞÿÿêĞ Ñá  Pã  
  àãÑÿÿê  ãÏÿÿê   ãp ÍåTğä   ãp ÍåTğäĞ Ñá  Pã  
  àãBÿÿê  ã@ÿÿêĞ Óá  Pã  
  àã3ÿÿê  ã1ÿÿêşÿÿê    (^ƒ€€À "runtime.morestack   ˆ^ƒ€€À &math/big.(*Int).Cmp   È^ƒ€€À &math/big.(*Int).Cmp   ¸^ƒ€€À "".hashToInt   à^ƒ€€À runtime.new   ˜^ƒ€€À 4math/big.(*Int).ModInverse   Ğ^ƒ€€À &math/big.(*Int).Mul   ˆ^ƒ€€À &math/big.(*Int).Mod   ¸^ƒ€€À &math/big.(*Int).Mul   ğ^ƒ€€À &math/big.(*Int).Mod   ˆ^ƒ€€À *math/big.(*Int).Bytes   ¨^ƒ€€À *math/big.(*Int).Bytes   €^ƒ€€À &math/big.(*Int).Mod   ¨^ƒ€€À &math/big.(*Int).Cmp   ˜.  "type.math/big.Int   8 ,"".autotmp_0035  type.int "".autotmp_0034  type.[]uint8 "".autotmp_0032  $type.*math/big.Int "".autotmp_0031  $type.*math/big.Int "".autotmp_0030  $type.*math/big.Int "".autotmp_0028  type.int math/big.xÂ·2 O$type.*math/big.Int math/big.xÂ·2 W$type.*math/big.Int "".x ?$type.*math/big.Int 
"".y1 _$type.*math/big.Int 
"".x1 G$type.*math/big.Int 
"".u2 /$type.*math/big.Int 
"".u1 '$type.*math/big.Int "".w 7$type.*math/big.Int "".e $type.*math/big.Int "".N $type.*math/big.Int "".c 4type.crypto/elliptic.Curve "".~r4 0type.bool "".s ($type.*math/big.Int "".r  $type.*math/big.Int "".hash type.[]uint8 "".pub  $type.*"".PublicKey ¨ì ô \‚	 . /121BA:9N J /     "".gcargsÂ·8 "".gclocalsÂ·9     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş"".init  €  € šå ]á “   “0 ‘   ›øÿÿšà-åˆ°Ÿå  Ûå  Rã  
ÿ0â ã  á Sá   ğä   ëı¼ú÷  ãX°Ÿå  Ëå   ë   ë   ëH Ÿå å   ë å å  ã  ã åå   ë å °Ÿå  ‹å  ã°Ÿå  Ëåğäşÿÿê                (^ƒ€€À "runtime.morestack   ^ƒ€€À "runtime.throwinit   ¸^ƒ€€À math/big.init   À^ƒ€€À io.init   È^ƒ€€À (crypto/elliptic.init   à^ƒ€€À runtime.new   ˜^ƒ€€À 0math/big.(*Int).SetInt64   à.  "".initdoneÂ·   è.  "".initdoneÂ·   ğ.  "type.math/big.Int   ø.  "".one    ( 
0( 0 ¸óô	  
       "".gcargsÂ·10 "".gclocalsÂ·11     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş.type..hash."".PublicKey ˆ  ˆ šå ]á “  “0 ‘   ›øÿÿšà-å å å  ã å å å å  Pã  €   ë å å  ã å å å å  Pã  €  ãå àå   ëğä(^ƒ€€À "runtime.morestack   ˆ^ƒ€€À "runtime.interhash   ø^ƒ€€À runtime.memhash   "".p $type.*"".PublicKey "".s type.uintptr "".h  type.*uintptr 
  ! !         "".gcargsÂ·12 "".gclocalsÂ·13     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş*type..eq."".PublicKey ¨  ¨ šå ]á, “  “0 ‘   ›øÿÿš,à-å   ãâ â ä Ráüÿÿ0@å< å  Pã  € å$åå(å8 å  Pã  € ååå å0å$å  á Sá   å å  å å$ å å( å å   ë<`å8På0@å İå  Pã  
0•å–å Sá  
  ã Äå,ğä •å–å Rá  
  ã Äå,ğä ã Äå,ğä  ã Äå,ğä(^ƒ€€À "runtime.morestack   Ğ^ƒ€€À runtime.ifaceeq    P"".autotmp_0040 4type.crypto/elliptic.Curve "".autotmp_0039 4type.crypto/elliptic.Curve "".q $type.*"".PublicKey "".p $type.*"".PublicKey "".s type.uintptr 
"".eq  type.*bool 
X= E E  **) 
 *     "".gcargsÂ·14 "".gclocalsÂ·15     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş&"".(*PublicKey).Add    šå ]á( “  “0 ‘   ›øÿÿš(à-å0šå(0ƒâ0Šå   ã â â ä Ráüÿÿ   ã   ã   ã   ã, å  Pã  € å åå$å0 å å4 å å8 å å< å å  âåå  å å0ÿ/á0å å@0åD å0šå(0Câ0Šå(ğä(^ƒ€€À "runtime.morestack   8H"crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int $crypto/elliptic.y2  $type.*math/big.Int $crypto/elliptic.x2 $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey 
P* 2 2  ):9 
 )	     "".gcargsÂ·16 "".gclocalsÂ·17     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş,"".(*PublicKey).Double ğ  ğ šå ]á  “  “0 ‘   ›øÿÿš à-å0šå 0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã   ã   ã   ã$ å  Pã  € åååå( å å, å å âåå  å å0ÿ/á0å å00å4 å0šå 0Câ0Šå ğä(^ƒ€€À "runtime.morestack   (8
"crypto/elliptic.y  $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey 
@& . .  %*) 
 %	     "".gcargsÂ·18 "".gclocalsÂ·19     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş2"".(*PublicKey).IsOnCurve È  È šå ]á “  “0 ‘   ›øÿÿšà-å0šå0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã  å  Pã  € åååå$ å å( å å âåå  å å0ÿ/á İå, Íå0šå0Câ0Šåğä(^ƒ€€À "runtime.morestack    0"".~r3 type.bool "crypto/elliptic.y $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int ""..this  $type.*"".PublicKey 
8! ) )  ""! 
 "     "".gcargsÂ·20 "".gclocalsÂ·21     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş,"".(*PublicKey).Params ¨  ¨ šå ]á “  “0 ‘   ›øÿÿšà-å0šå0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã å  Pã  € åååå âåå  å  å0ÿ/á å å0šå0Câ0Šåğä(^ƒ€€À "runtime.morestack    "".~r1 Btype.*crypto/elliptic.CurveParams ""..this  $type.*"".PublicKey 
( % %   
      "".gcargsÂ·22 "".gclocalsÂ·23     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş<"".(*PublicKey).ScalarBaseMult €  € šå ]á$ “  “0 ‘   ›øÿÿš$à-å0šå$0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã   ã   ã   ã( å  Pã  € ååå å, å å0 å å4 å å âåå  å$ å0ÿ/á0å å80å< å0šå$0Câ0Šå$ğä(^ƒ€€À "runtime.morestack   0@"crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int "crypto/elliptic.k type.[]uint8 ""..this  $type.*"".PublicKey 
H( 0 0  '21 
 '	     "".gcargsÂ·24 "".gclocalsÂ·25     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş4"".(*PublicKey).ScalarMult      šå ]á, “   “0 ‘   ›øÿÿš,à-å0šå,0ƒâ0Šå   ã$â â ä Ráüÿÿ   ã   ã   ã   ã0 å  Pã  € å$åå(å4 å å8 å å< å å@ å åD å å$ âåå  å( å0ÿ/á0å  åH0åL å0šå,0Câ0Šå,ğä(^ƒ€€À "runtime.morestack   @P"crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int "crypto/elliptic.k type.[]uint8 $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey 
X, 4 4  +BA 
 +	     "".gcargsÂ·26 "".gclocalsÂ·27     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş "".PublicKey.Add ø  ø šå ]á( “(  “0 ‘   ›øÿÿš(à-å0šå(0ƒâ0Šå   ã â â ä Ráüÿÿ   ã   ã   ã   ã, å  å0 å$ å< å å@ å åD å åH å å  âåå  å å0ÿ/á0å åL0åP å0šå(0Câ0Šå(ğä(^ƒ€€À "runtime.morestack   PH"crypto/elliptic.y H$type.*math/big.Int "crypto/elliptic.x @$type.*math/big.Int $crypto/elliptic.y2 8$type.*math/big.Int $crypto/elliptic.x2 0$type.*math/big.Int $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey 
P' / /  &:9 
 &	     "".gcargsÂ·28 "".gclocalsÂ·29     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş&"".PublicKey.Double Ø  Ø šå ]á  “   “0 ‘   ›øÿÿš à-å0šå 0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã   ã   ã   ã$ å å( å å4 å å8 å å âåå  å å0ÿ/á0å å<0å@ å0šå 0Câ0Šå ğä(^ƒ€€À "runtime.morestack   @8
"crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey 
@# + +  "*) 
 "	     "".gcargsÂ·30 "".gclocalsÂ·31     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş,"".PublicKey.IsOnCurve °  ° šå ]á “  “0 ‘   ›øÿÿšà-å0šå0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã  å å$ å å0 å å4 å å âåå  å å0ÿ/á İå8 Íå0šå0Câ0Šåğä(^ƒ€€À "runtime.morestack   80"".~r3 0type.bool "crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int ""..this  "type."".PublicKey 
8 & &  "! 
      "".gcargsÂ·32 "".gclocalsÂ·33     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş&"".PublicKey.Params    šå ]á “  “0 ‘   ›øÿÿšà-å0šå0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã å å å å âåå  å  å0ÿ/á å( å0šå0Câ0Šåğä(^ƒ€€À "runtime.morestack   ( "".~r1  Btype.*crypto/elliptic.CurveParams ""..this  "type."".PublicKey 
( " "   
      "".gcargsÂ·34 "".gclocalsÂ·35     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş6"".PublicKey.ScalarBaseMult è  è šå ]á$ “$  “0 ‘   ›øÿÿš$à-å0šå$0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã   ã   ã   ã( å å, å  å8 å å< å å@ å å âåå  å$ å0ÿ/á0å åD0åH å0šå$0Câ0Šå$ğä(^ƒ€€À "runtime.morestack   H@"crypto/elliptic.y @$type.*math/big.Int "crypto/elliptic.x 8$type.*math/big.Int "crypto/elliptic.k  type.[]uint8 ""..this  "type."".PublicKey 
H% - -  $21 
 $	     "".gcargsÂ·36 "".gclocalsÂ·37     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş."".PublicKey.ScalarMult ˆ  ˆ šå ]á, “,  “0 ‘   ›øÿÿš,à-å0šå,0ƒâ0Šå   ã$â â ä Ráüÿÿ   ã   ã   ã   ã0 å$ å4 å( å@ å åD å åH å åL å åP å å$ âåå  å( å0ÿ/á0å  åT0åX å0šå,0Câ0Šå,ğä(^ƒ€€À "runtime.morestack   XP"crypto/elliptic.y P$type.*math/big.Int "crypto/elliptic.x H$type.*math/big.Int "crypto/elliptic.k 0type.[]uint8 $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey 
X) 1 1  (BA 
 (	     "".gcargsÂ·38 "".gclocalsÂ·39     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş0type..hash."".PrivateKey ˆ  ˆ šå ]á “  “0 ‘   ›øÿÿšà-å å å  ã å å å å  Pã  €   ë å å  ã å å å å  Pã  €  ãå àå   ëğä(^ƒ€€À "runtime.morestack   ˆ^ƒ€€À .type..hash."".PublicKey   ø^ƒ€€À runtime.memhash   "".p &type.*"".PrivateKey "".s type.uintptr "".h  type.*uintptr 
  ! !         "".gcargsÂ·40 "".gclocalsÂ·41     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş,type..eq."".PrivateKey Ğ  Ğ šå ]á4 “  “0 ‘   ›øÿÿš4à-å   ãâ â ä Ráüÿÿ8@å@0å  Sã 0ƒD å  Rã  ‚ å ’å,å’å0å 0å “å$å“å(å$0å,å  á Sá"  $ å å( å å, å å0 å å   ë `åPå8@å İå  Pã  
0–å•å Sá   –å•å Rá  @ å0åD åå Sá  
  ã Äå4ğä ã Äå4ğä  ã Äå4ğä(^ƒ€€À "runtime.morestack   à^ƒ€€À runtime.ifaceeq    `"".autotmp_0082 4type.crypto/elliptic.Curve "".autotmp_0081 4type.crypto/elliptic.Curve "".autotmp_0080 /$type.*"".PublicKey "".autotmp_0079 '$type.*"".PublicKey "".q &type.*"".PrivateKey "".p &type.*"".PrivateKey "".s type.uintptr 
"".eq  type.*bool 
hB J J  ,*) 
 ,     "".gcargsÂ·42 "".gclocalsÂ·43     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş("".(*PrivateKey).Add    šå ]á( “  “0 ‘   ›øÿÿš(à-å0šå(0ƒâ0Šå   ã â â ä Ráüÿÿ   ã   ã   ã   ã, å  Pã  € å åå$å0 å å4 å å8 å å< å å  âåå  å å0ÿ/á0å å@0åD å0šå(0Câ0Šå(ğä(^ƒ€€À "runtime.morestack   8H"crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int $crypto/elliptic.y2  $type.*math/big.Int $crypto/elliptic.x2 $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey 
P* 2 2  ):9 
 )	     "".gcargsÂ·44 "".gclocalsÂ·45     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş."".(*PrivateKey).Double ğ  ğ šå ]á  “  “0 ‘   ›øÿÿš à-å0šå 0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã   ã   ã   ã$ å  Pã  € åååå( å å, å å âåå  å å0ÿ/á0å å00å4 å0šå 0Câ0Šå ğä(^ƒ€€À "runtime.morestack   (8
"crypto/elliptic.y  $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey 
@& . .  %*) 
 %	     "".gcargsÂ·46 "".gclocalsÂ·47     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş4"".(*PrivateKey).IsOnCurve È  È šå ]á “  “0 ‘   ›øÿÿšà-å0šå0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã  å  Pã  € åååå$ å å( å å âåå  å å0ÿ/á İå, Íå0šå0Câ0Šåğä(^ƒ€€À "runtime.morestack    0"".~r3 type.bool "crypto/elliptic.y $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int ""..this  &type.*"".PrivateKey 
8! ) )  ""! 
 "     "".gcargsÂ·48 "".gclocalsÂ·49     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş."".(*PrivateKey).Params ¨  ¨ šå ]á “  “0 ‘   ›øÿÿšà-å0šå0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã å  Pã  € åååå âåå  å  å0ÿ/á å å0šå0Câ0Šåğä(^ƒ€€À "runtime.morestack    "".~r1 Btype.*crypto/elliptic.CurveParams ""..this  &type.*"".PrivateKey 
( % %   
      "".gcargsÂ·50 "".gclocalsÂ·51     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş>"".(*PrivateKey).ScalarBaseMult €  € šå ]á$ “  “0 ‘   ›øÿÿš$à-å0šå$0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã   ã   ã   ã( å  Pã  € ååå å, å å0 å å4 å å âåå  å$ å0ÿ/á0å å80å< å0šå$0Câ0Šå$ğä(^ƒ€€À "runtime.morestack   0@"crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int "crypto/elliptic.k type.[]uint8 ""..this  &type.*"".PrivateKey 
H( 0 0  '21 
 '	     "".gcargsÂ·52 "".gclocalsÂ·53     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş6"".(*PrivateKey).ScalarMult      šå ]á, “   “0 ‘   ›øÿÿš,à-å0šå,0ƒâ0Šå   ã$â â ä Ráüÿÿ   ã   ã   ã   ã0 å  Pã  € å$åå(å4 å å8 å å< å å@ å åD å å$ âåå  å( å0ÿ/á0å  åH0åL å0šå,0Câ0Šå,ğä(^ƒ€€À "runtime.morestack   @P"crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int "crypto/elliptic.k type.[]uint8 $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey 
X, 4 4  +BA 
 +	     "".gcargsÂ·54 "".gclocalsÂ·55     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş""".PrivateKey.Add ø  ø šå ]á( “,  “0 ‘   ›øÿÿš(à-å0šå(0ƒâ0Šå   ã â â ä Ráüÿÿ   ã   ã   ã   ã, å  å0 å$ å@ å åD å åH å åL å å  âåå  å å0ÿ/á0å åP0åT å0šå(0Câ0Šå(ğä(^ƒ€€À "runtime.morestack   XH"crypto/elliptic.y P$type.*math/big.Int "crypto/elliptic.x H$type.*math/big.Int $crypto/elliptic.y2 @$type.*math/big.Int $crypto/elliptic.x2 8$type.*math/big.Int $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey 
P' / /  &:9 
 &	     "".gcargsÂ·56 "".gclocalsÂ·57     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş("".PrivateKey.Double Ø  Ø šå ]á  “$  “0 ‘   ›øÿÿš à-å0šå 0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã   ã   ã   ã$ å å( å å8 å å< å å âåå  å å0ÿ/á0å å@0åD å0šå 0Câ0Šå ğä(^ƒ€€À "runtime.morestack   H8
"crypto/elliptic.y @$type.*math/big.Int "crypto/elliptic.x 8$type.*math/big.Int $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey 
@# + +  "*) 
 "	     "".gcargsÂ·58 "".gclocalsÂ·59     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş."".PrivateKey.IsOnCurve °  ° šå ]á “   “0 ‘   ›øÿÿšà-å0šå0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã  å å$ å å4 å å8 å å âåå  å å0ÿ/á İå< Íå0šå0Câ0Šåğä(^ƒ€€À "runtime.morestack   @0"".~r3 8type.bool "crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int ""..this  $type."".PrivateKey 
8 & &  "! 
      "".gcargsÂ·60 "".gclocalsÂ·61     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş("".PrivateKey.Params    šå ]á “  “0 ‘   ›øÿÿšà-å0šå0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã å å å å âåå  å  å0ÿ/á å, å0šå0Câ0Šåğä(^ƒ€€À "runtime.morestack   0 "".~r1 (Btype.*crypto/elliptic.CurveParams ""..this  $type."".PrivateKey 
( " "   
      "".gcargsÂ·62 "".gclocalsÂ·63     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş8"".PrivateKey.ScalarBaseMult è  è šå ]á$ “(  “0 ‘   ›øÿÿš$à-å0šå$0ƒâ0Šå   ãâ â ä Ráüÿÿ   ã   ã   ã   ã( å å, å  å< å å@ å åD å å âåå  å$ å0ÿ/á0å åH0åL å0šå$0Câ0Šå$ğä(^ƒ€€À "runtime.morestack   P@"crypto/elliptic.y H$type.*math/big.Int "crypto/elliptic.x @$type.*math/big.Int "crypto/elliptic.k (type.[]uint8 ""..this  $type."".PrivateKey 
H% - -  $21 
 $	     "".gcargsÂ·64 "".gclocalsÂ·65     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş0"".PrivateKey.ScalarMult ˆ  ˆ šå ]á, “0  “0 ‘   ›øÿÿš,à-å0šå,0ƒâ0Šå   ã$â â ä Ráüÿÿ   ã   ã   ã   ã0 å$ å4 å( åD å åH å åL å åP å åT å å$ âåå  å( å0ÿ/á0å  åX0å\ å0šå,0Câ0Šå,ğä(^ƒ€€À "runtime.morestack   `P"crypto/elliptic.y X$type.*math/big.Int "crypto/elliptic.x P$type.*math/big.Int "crypto/elliptic.k 8type.[]uint8 $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey 
X) 1 1  (BA 
 (	     "".gcargsÂ·66 "".gclocalsÂ·67     j/home/pi/go_build/hg/go/src/pkg/crypto/ecdsa/ecdsa.goş"".gclocalsÂ·1  ¨  ¨
                                                                     ş"".gcargsÂ·0  ¨  ¨
      "      "     "     "     "     "     "	     "	     "	     "	   ş"".gclocalsÂ·3  X  X                                      ş"".gcargsÂ·2  X  X      "      "     "     "	     "	   ş"".gclocalsÂ·5  x  x                                                    ş"".gcargsÂ·4  x  x                                              ş"".gclocalsÂ·7  è  è                   @     D     D     A     A     A     A     Q     Q     A     @     @   ş"".gcargsÂ·6  è  è      R      R@     R@     R@    R@    R@    R@    RP    R    R    R    RP    RP    RP  ş"".gclocalsÂ·9  ¨  ¨                      $      $      $      %      %     $     D$     @$     P$     $     $    A $    A $                     ş"".gcargsÂ·8  ¨  ¨                                                                                              ş"".gclocalsÂ·11  @  @                                ş"".gcargsÂ·10  @  @                                ş*"".one  $type.*math/big.Int   ş,"".initdoneÂ·  type.uint8   ş,"".randFieldElementÂ·f        .  &"".randFieldElement   ş(runtime.makesliceÂ·f        .  "runtime.makeslice   şio.ReadFullÂ·f        .  io.ReadFull   şruntime.newÂ·f        .  runtime.new   ş6math/big.(*Int).SetBytesÂ·f        .  0math/big.(*Int).SetBytes   ş,math/big.(*Int).SubÂ·f        .  &math/big.(*Int).Sub   ş,math/big.(*Int).ModÂ·f        .  &math/big.(*Int).Mod   ş,math/big.(*Int).AddÂ·f        .  &math/big.(*Int).Add   ş,runtime.throwreturnÂ·f        .  &runtime.throwreturn   ş""".GenerateKeyÂ·f        .  "".GenerateKey   ş0math/big.(*Int).BytesÂ·f        .  *math/big.(*Int).Bytes   ş"".hashToIntÂ·f        .  "".hashToInt   ş2math/big.(*Int).BitLenÂ·f        .  ,math/big.(*Int).BitLen   ş*runtime.panicsliceÂ·f        .  $runtime.panicslice   ş,math/big.(*Int).RshÂ·f        .  &math/big.(*Int).Rsh   ş"".SignÂ·f        .  "".Sign   ş:math/big.(*Int).ModInverseÂ·f        .  4math/big.(*Int).ModInverse   ş,math/big.(*Int).MulÂ·f        .  &math/big.(*Int).Mul   ş"".VerifyÂ·f        .  "".Verify   ş,math/big.(*Int).CmpÂ·f        .  &math/big.(*Int).Cmp   ş"".initÂ·f        .  "".init   ş(runtime.throwinitÂ·f        .  "runtime.throwinit   ş math/big.initÂ·f        .  math/big.init   şio.initÂ·f        .  io.init   ş.crypto/elliptic.initÂ·f        .  (crypto/elliptic.init   ş6math/big.(*Int).SetInt64Â·f        .  0math/big.(*Int).SetInt64   ştype..gc.uint8           ş type..gc.[]uint8 (  (   
               .  type..gc.uint8   ş&go.string."[]uint8"            []uint8  . &go.string."[]uint8"   ştype.[]uint8 P  P   ß~.8                             .   runtime.algarray    .   type..gc.[]uint8   (.  &go.string."[]uint8"   8.  *go.weak.type.*[]uint8   @.  "runtime.zerovalue   H.  type.uint8   ş6go.typelink.[]uint8/[]uint8        .  type.[]uint8   ş"".gclocalsÂ·13                      ş"".gcargsÂ·12  8  8                      ş"".gclocalsÂ·15  (  (   
       
        ş"".gcargsÂ·14  (  (      Q      Q    ş,type..alg."".PublicKey                      .  .type..hash."".PublicKey   .  *type..eq."".PublicKey   .   runtime.memprint   .  $runtime.memcopy128   ş,type..gc.math/big.Word           ş*type..gc.math/big.Int (  (   
              .  ,type..gc.math/big.Word   ş*type..gc."".PublicKey P  P   	                               (.  *type..gc.math/big.Int   @.  *type..gc.math/big.Int   ş,type..gc.*"".PublicKey (  (                  .  *type..gc."".PublicKey   ş8go.string."*ecdsa.PublicKey" 8  2       *ecdsa.PublicKey  . 8go.string."*ecdsa.PublicKey"   ş"".gclocalsÂ·17  (  (                  ş"".gcargsÂ·16  (  (      U     U   ş"".gclocalsÂ·19  (  (                  ş"".gcargsÂ·18  (  (   
      
       ş"".gclocalsÂ·21  (  (                  ş"".gcargsÂ·20  (  (                ş"".gclocalsÂ·23  (  (                  ş"".gcargsÂ·22  (  (                ş"".gclocalsÂ·25  (  (                  ş"".gcargsÂ·24  (  (                ş"".gclocalsÂ·27  (  (                  ş"".gcargsÂ·26  (  (      U      U    şîtype..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¸    S   func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  . ¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸   ²% •                                                                             .à  runtime.algarray    .  îtype..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (.  ¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   8.  øgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h.¨ ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €.  $type.*"".PublicKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  $type.*math/big.Int    .  $type.*math/big.Int   ¨.  $type.*math/big.Int   °.  $type.*math/big.Int   ş²type..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş–go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       ?   func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)  . –go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   şªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨   ö&‡?                                                                     .à  runtime.algarray    .  ²type..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (.  –go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   8.  ¼go.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h.˜ ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €.  $type.*"".PublicKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  $type.*math/big.Int    .  $type.*math/big.Int   ş~type..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool                    şvgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool" p  p    /   func(*ecdsa.PublicKey, *big.Int, *big.Int) bool  . vgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool"   şvtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool        ›²N¢                                                                 .à  runtime.algarray    .  ~type..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   (.  vgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool"   8.  ˆgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   @.  "runtime.zerovalue   P.€ vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   h.˜ vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   €.  $type.*"".PublicKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  type.bool   şrtype..gc.func(*"".PublicKey) *crypto/elliptic.CurveParams                    şpgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams" p  j    ,   func(*ecdsa.PublicKey) *elliptic.CurveParams  . pgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams"   şjtype.func(*"".PublicKey) *crypto/elliptic.CurveParams      Zmdš                                                         .à  runtime.algarray    .  rtype..gc.func(*"".PublicKey) *crypto/elliptic.CurveParams   (.  pgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams"   8.  |go.weak.type.*func(*"".PublicKey) *crypto/elliptic.CurveParams   @.  "runtime.zerovalue   P.€ jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   h.ˆ jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   €.  $type.*"".PublicKey   ˆ.  Btype.*crypto/elliptic.CurveParams   şˆtype..gc.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)                    ş€go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)" €  z    4   func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)  . €go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   ş€type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)        3nÄ7                                                                 .à  runtime.algarray    .  ˆtype..gc.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   (.  €go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   8.  ’go.weak.type.*func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   h. €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   €.  $type.*"".PublicKey   ˆ.  type.[]uint8   .  $type.*math/big.Int   ˜.  $type.*math/big.Int   şÄtype..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)                    ş¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¢    H   func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  . ¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °   fy<                                                                         .à  runtime.algarray    .  Ätype..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   (.  ¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   8.  Îgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h.  ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €.  $type.*"".PublicKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  type.[]uint8    .  $type.*math/big.Int   ¨.  $type.*math/big.Int   şgo.string."Add"          Add  . go.string."Add"   şĞtype..gc.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    şšgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ˜  ”    A   func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  . šgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şÈtype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) °  °   ğ\áõ                                                                         .à  runtime.algarray    .  Ğtype..gc.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (.  šgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   8.  Úgo.weak.type.*func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h.  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €.  $type.*math/big.Int   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  $type.*math/big.Int    .  $type.*math/big.Int   ¨.  $type.*math/big.Int   ş$go.string."Double"           Double  . $go.string."Double"   ş”type..gc.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    şrgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)" p  l    -   func(*big.Int, *big.Int) (*big.Int, *big.Int)  . rgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)"   şŒtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)        3`1
                                                                 .à  runtime.algarray    .  ”type..gc.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (.  rgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)"   8.  go.weak.type.*func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h. Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €.  $type.*math/big.Int   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  $type.*math/big.Int   ş*go.string."IsOnCurve" (  $    	   IsOnCurve  . *go.string."IsOnCurve"   ş`type..gc.func(*math/big.Int, *math/big.Int) bool                    şRgo.string."func(*big.Int, *big.Int) bool" P  L       func(*big.Int, *big.Int) bool  . Rgo.string."func(*big.Int, *big.Int) bool"   şXtype.func(*math/big.Int, *math/big.Int) bool ˜  ˜   À§                                                             .à  runtime.algarray    .  `type..gc.func(*math/big.Int, *math/big.Int) bool   (.  Rgo.string."func(*big.Int, *big.Int) bool"   8.  jgo.weak.type.*func(*math/big.Int, *math/big.Int) bool   @.  "runtime.zerovalue   P.€ Xtype.func(*math/big.Int, *math/big.Int) bool   h. Xtype.func(*math/big.Int, *math/big.Int) bool   €.  $type.*math/big.Int   ˆ.  $type.*math/big.Int   .  type.bool   ş$go.string."Params"           Params  . $go.string."Params"   şXtype..gc.func() *crypto/elliptic.CurveParams                    şPgo.string."func() *elliptic.CurveParams" P  J       func() *elliptic.CurveParams  . Pgo.string."func() *elliptic.CurveParams"   şPtype.func() *crypto/elliptic.CurveParams ˆ  ˆ   ˆ¨"å                                                       .à  runtime.algarray    .  Xtype..gc.func() *crypto/elliptic.CurveParams   (.  Pgo.string."func() *elliptic.CurveParams"   8.  bgo.weak.type.*func() *crypto/elliptic.CurveParams   @.  "runtime.zerovalue   P.€ Ptype.func() *crypto/elliptic.CurveParams   h.€ Ptype.func() *crypto/elliptic.CurveParams   €.  Btype.*crypto/elliptic.CurveParams   ş4go.string."ScalarBaseMult" 0  .       ScalarBaseMult  . 4go.string."ScalarBaseMult"   şjtype..gc.func([]uint8) (*math/big.Int, *math/big.Int)                    ş\go.string."func([]uint8) (*big.Int, *big.Int)" X  V    "   func([]uint8) (*big.Int, *big.Int)  . \go.string."func([]uint8) (*big.Int, *big.Int)"   şbtype.func([]uint8) (*math/big.Int, *math/big.Int) ˜  ˜   €Ÿ.l                                                             .à  runtime.algarray    .  jtype..gc.func([]uint8) (*math/big.Int, *math/big.Int)   (.  \go.string."func([]uint8) (*big.Int, *big.Int)"   8.  tgo.weak.type.*func([]uint8) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ btype.func([]uint8) (*math/big.Int, *math/big.Int)   h.ˆ btype.func([]uint8) (*math/big.Int, *math/big.Int)   €.  type.[]uint8   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ş,go.string."ScalarMult" (  &    
   ScalarMult  . ,go.string."ScalarMult"   ş¦type..gc.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)                    ş„go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" €  ~    6   func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  . „go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ştype.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) ¨  ¨   ašÙÂ                                                                     .à  runtime.algarray    .  ¦type..gc.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   (.  „go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   8.  °go.weak.type.*func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h.˜ type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €.  $type.*math/big.Int   ˆ.  $type.*math/big.Int   .  type.[]uint8   ˜.  $type.*math/big.Int    .  $type.*math/big.Int   ş$type.*"".PublicKey  ˜  ˜   €Ğ/                                                                                                                                                                                               L.€  runtime.algarray    .  ,type..gc.*"".PublicKey   (.  8go.string."*ecdsa.PublicKey"   8.  6go.weak.type.**"".PublicKey   @.  "runtime.zerovalue   H.  "type."".PublicKey   0.P $type.*"".PublicKey   `.x $type.*"".PublicKey   x.  go.string."Add"   ˆ.  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   .  ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜.  &"".(*PublicKey).Add    .  &"".(*PublicKey).Add   ¨.  $go.string."Double"   ¸.  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   À.  ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È.  ,"".(*PublicKey).Double   Ğ.  ,"".(*PublicKey).Double   Ø.  *go.string."IsOnCurve"   è.  Xtype.func(*math/big.Int, *math/big.Int) bool   ğ.  vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   ø.  2"".(*PublicKey).IsOnCurve   €.  2"".(*PublicKey).IsOnCurve   ˆ.  $go.string."Params"   ˜.  Ptype.func() *crypto/elliptic.CurveParams    .  jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   ¨.  ,"".(*PublicKey).Params   °.  ,"".(*PublicKey).Params   ¸.  4go.string."ScalarBaseMult"   È.  btype.func([]uint8) (*math/big.Int, *math/big.Int)   Ğ.  €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   Ø.  <"".(*PublicKey).ScalarBaseMult   à.  <"".(*PublicKey).ScalarBaseMult   è.  ,go.string."ScalarMult"   ø.  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €.  ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ.  4"".(*PublicKey).ScalarMult   .  4"".(*PublicKey).ScalarMult   ş6go.string."ecdsa.PublicKey" 0  0       ecdsa.PublicKey  . 6go.string."ecdsa.PublicKey"   şgo.string."X"          X  . go.string."X"   şgo.string."Y"          Y  . go.string."Y"   ş"".gclocalsÂ·29  (  (                  ş"".gcargsÂ·28  (  (      RU     RU   ş"".gclocalsÂ·31  (  (                  ş"".gcargsÂ·30  (  (      R     R   ş"".gclocalsÂ·33  (  (                  ş"".gcargsÂ·32  (  (      R     R   ş"".gclocalsÂ·35  (  (                  ş"".gcargsÂ·34  (  (   
   R   
   R    ş"".gclocalsÂ·37  (  (                  ş"".gcargsÂ·36  (  (      R     R   ş"".gclocalsÂ·39  (  (                  ş"".gcargsÂ·38  (  (      R     R   şìtype..gc.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¶    R   func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  . ¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸   ôgİz                                                                             .à  runtime.algarray    .  ìtype..gc.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (.  ¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   8.  ögo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h.¨ ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €.  "type."".PublicKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  $type.*math/big.Int    .  $type.*math/big.Int   ¨.  $type.*math/big.Int   °.  $type.*math/big.Int   ş°type..gc.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       >   func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)  . ”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨   º|¶ù                                                                     .à  runtime.algarray    .  °type..gc.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (.  ”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   8.  ºgo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h.˜ ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €.  "type."".PublicKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  $type.*math/big.Int    .  $type.*math/big.Int   ş|type..gc.func("".PublicKey, *math/big.Int, *math/big.Int) bool                    ştgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool" p  n    .   func(ecdsa.PublicKey, *big.Int, *big.Int) bool  . tgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool"   şttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool        Å                                                                 .à  runtime.algarray    .  |type..gc.func("".PublicKey, *math/big.Int, *math/big.Int) bool   (.  tgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool"   8.  †go.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int) bool   @.  "runtime.zerovalue   P.€ ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   h.˜ ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   €.  "type."".PublicKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  type.bool   şptype..gc.func("".PublicKey) *crypto/elliptic.CurveParams                    şngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams" h  h    +   func(ecdsa.PublicKey) *elliptic.CurveParams  . ngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams"   şhtype.func("".PublicKey) *crypto/elliptic.CurveParams      ¶ñÓ±                                                         .à  runtime.algarray    .  ptype..gc.func("".PublicKey) *crypto/elliptic.CurveParams   (.  ngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams"   8.  zgo.weak.type.*func("".PublicKey) *crypto/elliptic.CurveParams   @.  "runtime.zerovalue   P.€ htype.func("".PublicKey) *crypto/elliptic.CurveParams   h.ˆ htype.func("".PublicKey) *crypto/elliptic.CurveParams   €.  "type."".PublicKey   ˆ.  Btype.*crypto/elliptic.CurveParams   ş†type..gc.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)                    ş~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)" x  x    3   func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)  . ~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   ş~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)        g«¿                                                                 .à  runtime.algarray    .  †type..gc.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   (.  ~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   8.  go.weak.type.*func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   h. ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   €.  "type."".PublicKey   ˆ.  type.[]uint8   .  $type.*math/big.Int   ˜.  $type.*math/big.Int   şÂtype..gc.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)                    ş¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"         G   func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  . ¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   şºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °    “Rg                                                                         .à  runtime.algarray    .  Âtype..gc.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   (.  ¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   8.  Ìgo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h.  ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €.  "type."".PublicKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  type.[]uint8    .  $type.*math/big.Int   ¨.  $type.*math/big.Int   ş*go.string."PublicKey" (  $    	   PublicKey  . *go.string."PublicKey"   ş"type."".PublicKey         ™ÉZN                                                                                                                                                                                                                                                               Z.  ,type..alg."".PublicKey    .  *type..gc."".PublicKey   (.  6go.string."ecdsa.PublicKey"   8.  $type.*"".PublicKey   @.  "runtime.zerovalue   H.` "type."".PublicKey   p.  4type.crypto/elliptic.Curve   ˆ.  go.string."X"   ˜.  $type.*math/big.Int   °.  go.string."Y"   À.  $type.*math/big.Int   0.Ø "type."".PublicKey   Ø.  *go.string."PublicKey"   à.  "go.importpath."".   è.€ "type."".PublicKey   €.  go.string."Add"   .  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜.  ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)    .  &"".(*PublicKey).Add   ¨.   "".PublicKey.Add   °.  $go.string."Double"   À.  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È.  ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   Ğ.  ,"".(*PublicKey).Double   Ø.  &"".PublicKey.Double   à.  *go.string."IsOnCurve"   ğ.  Xtype.func(*math/big.Int, *math/big.Int) bool   ø.  ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   €.  2"".(*PublicKey).IsOnCurve   ˆ.  ,"".PublicKey.IsOnCurve   .  $go.string."Params"    .  Ptype.func() *crypto/elliptic.CurveParams   ¨.  htype.func("".PublicKey) *crypto/elliptic.CurveParams   °.  ,"".(*PublicKey).Params   ¸.  &"".PublicKey.Params   À.  4go.string."ScalarBaseMult"   Ğ.  btype.func([]uint8) (*math/big.Int, *math/big.Int)   Ø.  ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   à.  <"".(*PublicKey).ScalarBaseMult   è.  6"".PublicKey.ScalarBaseMult   ğ.  ,go.string."ScalarMult"   €.  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ.  ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   .  4"".(*PublicKey).ScalarMult   ˜.  ."".PublicKey.ScalarMult   ş"".gclocalsÂ·41                      ş"".gcargsÂ·40  8  8                      ş"".gclocalsÂ·43  (  (                 ş"".gcargsÂ·42  (  (      Q      Q    ş.type..alg."".PrivateKey                      .  0type..hash."".PrivateKey   .  ,type..eq."".PrivateKey   .   runtime.memprint   .  runtime.memcopy   ş,type..gc."".PrivateKey h  h   	                                         (.  *type..gc.math/big.Int   @.  *type..gc.math/big.Int   X.  *type..gc.math/big.Int   ş.type..gc.*"".PrivateKey (  (                  .  ,type..gc."".PrivateKey   ş:go.string."*ecdsa.PrivateKey" 8  4       *ecdsa.PrivateKey  . :go.string."*ecdsa.PrivateKey"   ş"".gclocalsÂ·45  (  (                  ş"".gcargsÂ·44  (  (      U     U   ş"".gclocalsÂ·47  (  (                  ş"".gcargsÂ·46  (  (   
      
       ş"".gclocalsÂ·49  (  (                  ş"".gcargsÂ·48  (  (                ş"".gclocalsÂ·51  (  (                  ş"".gcargsÂ·50  (  (                ş"".gclocalsÂ·53  (  (                  ş"".gcargsÂ·52  (  (                ş"".gclocalsÂ·55  (  (                  ş"".gcargsÂ·54  (  (      U      U    şğtype..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    şÀgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" À  º    T   func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  . Àgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸   w©Kı                                                                             .à  runtime.algarray    .  ğtype..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (.  Àgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   8.  úgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h.¨ ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €.  &type.*"".PrivateKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  $type.*math/big.Int    .  $type.*math/big.Int   ¨.  $type.*math/big.Int   °.  $type.*math/big.Int   ş´type..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)" ˜  ’    @   func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)  . ˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨   ;šN                                                                     .à  runtime.algarray    .  ´type..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (.  ˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   8.  ¾go.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h.˜ ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €.  &type.*"".PrivateKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  $type.*math/big.Int    .  $type.*math/big.Int   ş€type..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool                    şxgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool" x  r    0   func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool  . xgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool"   şxtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool        ^IŒ?                                                                 .à  runtime.algarray    .  €type..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   (.  xgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool"   8.  Šgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   @.  "runtime.zerovalue   P.€ xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   h.˜ xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   €.  &type.*"".PrivateKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  type.bool   şttype..gc.func(*"".PrivateKey) *crypto/elliptic.CurveParams                    şrgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams" p  l    -   func(*ecdsa.PrivateKey) *elliptic.CurveParams  . rgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams"   şltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams      “â                                                         .à  runtime.algarray    .  ttype..gc.func(*"".PrivateKey) *crypto/elliptic.CurveParams   (.  rgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams"   8.  ~go.weak.type.*func(*"".PrivateKey) *crypto/elliptic.CurveParams   @.  "runtime.zerovalue   P.€ ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   h.ˆ ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   €.  &type.*"".PrivateKey   ˆ.  Btype.*crypto/elliptic.CurveParams   şŠtype..gc.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)                    ş‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)" €  |    5   func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)  . ‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   ş‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)        ßÒ                                                                 .à  runtime.algarray    .  Štype..gc.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   (.  ‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   8.  ”go.weak.type.*func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   h. ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   €.  &type.*"".PrivateKey   ˆ.  type.[]uint8   .  $type.*math/big.Int   ˜.  $type.*math/big.Int   şÆtype..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)                    şªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¤    I   func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  . ªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °   ò	                                                                         .à  runtime.algarray    .  Ætype..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   (.  ªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   8.  Ğgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h.  ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €.  &type.*"".PrivateKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  type.[]uint8    .  $type.*math/big.Int   ¨.  $type.*math/big.Int   ş&type.*"".PrivateKey  ˜  ˜   Ñƒ¿Ê                                                                                                                                                                                               L.€  runtime.algarray    .  .type..gc.*"".PrivateKey   (.  :go.string."*ecdsa.PrivateKey"   8.  8go.weak.type.**"".PrivateKey   @.  "runtime.zerovalue   H.  $type."".PrivateKey   0.P &type.*"".PrivateKey   `.x &type.*"".PrivateKey   x.  go.string."Add"   ˆ.  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   .  ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜.  ("".(*PrivateKey).Add    .  ("".(*PrivateKey).Add   ¨.  $go.string."Double"   ¸.  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   À.  ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È.  ."".(*PrivateKey).Double   Ğ.  ."".(*PrivateKey).Double   Ø.  *go.string."IsOnCurve"   è.  Xtype.func(*math/big.Int, *math/big.Int) bool   ğ.  xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   ø.  4"".(*PrivateKey).IsOnCurve   €.  4"".(*PrivateKey).IsOnCurve   ˆ.  $go.string."Params"   ˜.  Ptype.func() *crypto/elliptic.CurveParams    .  ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   ¨.  ."".(*PrivateKey).Params   °.  ."".(*PrivateKey).Params   ¸.  4go.string."ScalarBaseMult"   È.  btype.func([]uint8) (*math/big.Int, *math/big.Int)   Ğ.  ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   Ø.  >"".(*PrivateKey).ScalarBaseMult   à.  >"".(*PrivateKey).ScalarBaseMult   è.  ,go.string."ScalarMult"   ø.  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €.  ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ.  6"".(*PrivateKey).ScalarMult   .  6"".(*PrivateKey).ScalarMult   ş8go.string."ecdsa.PrivateKey" 8  2       ecdsa.PrivateKey  . 8go.string."ecdsa.PrivateKey"   şgo.string."D"          D  . go.string."D"   ş"".gclocalsÂ·57  (  (                  ş"".gcargsÂ·56  (  (      RU    RU  ş"".gclocalsÂ·59  (  (                  ş"".gcargsÂ·58  (  (      R     R   ş"".gclocalsÂ·61  (  (                  ş"".gcargsÂ·60  (  (      R     R   ş"".gclocalsÂ·63  (  (                  ş"".gcargsÂ·62  (  (      R     R   ş"".gclocalsÂ·65  (  (                  ş"".gcargsÂ·64  (  (      R     R   ş"".gclocalsÂ·67  (  (                  ş"".gcargsÂ·66  (  (      RU     RU   şîtype..gc.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¸    S   func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  . ¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸   ü¼IÍ                                                                             .à  runtime.algarray    .  îtype..gc.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (.  ¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   8.  øgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h.¨ ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €.  $type."".PrivateKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  $type.*math/big.Int    .  $type.*math/big.Int   ¨.  $type.*math/big.Int   °.  $type.*math/big.Int   ş²type..gc.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş–go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       ?   func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)  . –go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   şªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨   Œÿ‰x                                                                     .à  runtime.algarray    .  ²type..gc.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (.  –go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   8.  ¼go.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h.˜ ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €.  $type."".PrivateKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  $type.*math/big.Int    .  $type.*math/big.Int   ş~type..gc.func("".PrivateKey, *math/big.Int, *math/big.Int) bool                    şvgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool" p  p    /   func(ecdsa.PrivateKey, *big.Int, *big.Int) bool  . vgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool"   şvtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool        "‚ù                                                                 .à  runtime.algarray    .  ~type..gc.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   (.  vgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool"   8.  ˆgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int) bool   @.  "runtime.zerovalue   P.€ vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   h.˜ vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   €.  $type."".PrivateKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  type.bool   şrtype..gc.func("".PrivateKey) *crypto/elliptic.CurveParams                    şpgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams" p  j    ,   func(ecdsa.PrivateKey) *elliptic.CurveParams  . pgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams"   şjtype.func("".PrivateKey) *crypto/elliptic.CurveParams      Ó'î                                                         .à  runtime.algarray    .  rtype..gc.func("".PrivateKey) *crypto/elliptic.CurveParams   (.  pgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams"   8.  |go.weak.type.*func("".PrivateKey) *crypto/elliptic.CurveParams   @.  "runtime.zerovalue   P.€ jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   h.ˆ jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   €.  $type."".PrivateKey   ˆ.  Btype.*crypto/elliptic.CurveParams   şˆtype..gc.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)                    ş€go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)" €  z    4   func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)  . €go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   ş€type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)        |Œ¤»                                                                 .à  runtime.algarray    .  ˆtype..gc.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   (.  €go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   8.  ’go.weak.type.*func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   h. €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   €.  $type."".PrivateKey   ˆ.  type.[]uint8   .  $type.*math/big.Int   ˜.  $type.*math/big.Int   şÄtype..gc.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)                    ş¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¢    H   func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  . ¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °   ¥ÑX                                                                         .à  runtime.algarray    .  Ätype..gc.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   (.  ¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   8.  Îgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   @.  "runtime.zerovalue   P.€ ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h.  ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €.  $type."".PrivateKey   ˆ.  $type.*math/big.Int   .  $type.*math/big.Int   ˜.  type.[]uint8    .  $type.*math/big.Int   ¨.  $type.*math/big.Int   ş,go.string."PrivateKey" (  &    
   PrivateKey  . ,go.string."PrivateKey"   ş$type."".PrivateKey  ø  ø   A;!–                                                                                                                                                                                                                                            V.  .type..alg."".PrivateKey    .  ,type..gc."".PrivateKey   (.  8go.string."ecdsa.PrivateKey"   8.  &type.*"".PrivateKey   @.  "runtime.zerovalue   H.` $type."".PrivateKey   p.  "type."".PublicKey   ˆ.  go.string."D"   ˜.  $type.*math/big.Int   0.° $type."".PrivateKey   °.  ,go.string."PrivateKey"   ¸.  "go.importpath."".   À.Ø $type."".PrivateKey   Ø.  go.string."Add"   è.  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ğ.  ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ø.  ("".(*PrivateKey).Add   €.  """.PrivateKey.Add   ˆ.  $go.string."Double"   ˜.  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)    .  ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ¨.  ."".(*PrivateKey).Double   °.  ("".PrivateKey.Double   ¸.  *go.string."IsOnCurve"   È.  Xtype.func(*math/big.Int, *math/big.Int) bool   Ğ.  vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   Ø.  4"".(*PrivateKey).IsOnCurve   à.  ."".PrivateKey.IsOnCurve   è.  $go.string."Params"   ø.  Ptype.func() *crypto/elliptic.CurveParams   €.  jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   ˆ.  ."".(*PrivateKey).Params   .  ("".PrivateKey.Params   ˜.  4go.string."ScalarBaseMult"   ¨.  btype.func([]uint8) (*math/big.Int, *math/big.Int)   °.  €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   ¸.  >"".(*PrivateKey).ScalarBaseMult   À.  8"".PrivateKey.ScalarBaseMult   È.  ,go.string."ScalarMult"   Ø.  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   à.  ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   è.  6"".(*PrivateKey).ScalarMult   ğ.  0"".PrivateKey.ScalarMult   ş&go.string."runtime"            runtime  . &go.string."runtime"   ş,go.importpath.runtime.           . &go.string."runtime"   şgo.string."io"          io  . go.string."io"   ş"go.importpath.io.           . go.string."io"   ş6go.string."crypto/elliptic" 0  0       crypto/elliptic  . 6go.string."crypto/elliptic"   ş<go.importpath.crypto/elliptic.           . 6go.string."crypto/elliptic"   ş(go.string."math/big" (  "       math/big  . (go.string."math/big"   ş.go.importpath.math/big.           . (go.string."math/big"   ş4type..hash."".PublicKeyÂ·f        .  .type..hash."".PublicKey   ş(runtime.interhashÂ·f        .  "runtime.interhash   ş$runtime.memhashÂ·f        .  runtime.memhash   ş0type..eq."".PublicKeyÂ·f        .  *type..eq."".PublicKey   ş$runtime.ifaceeqÂ·f        .  runtime.ifaceeq   ş,"".(*PublicKey).AddÂ·f        .  &"".(*PublicKey).Add   ş2"".(*PublicKey).DoubleÂ·f        .  ,"".(*PublicKey).Double   ş8"".(*PublicKey).IsOnCurveÂ·f        .  2"".(*PublicKey).IsOnCurve   ş2"".(*PublicKey).ParamsÂ·f        .  ,"".(*PublicKey).Params   şB"".(*PublicKey).ScalarBaseMultÂ·f        .  <"".(*PublicKey).ScalarBaseMult   ş:"".(*PublicKey).ScalarMultÂ·f        .  4"".(*PublicKey).ScalarMult   ş&"".PublicKey.AddÂ·f        .   "".PublicKey.Add   ş,"".PublicKey.DoubleÂ·f        .  &"".PublicKey.Double   ş2"".PublicKey.IsOnCurveÂ·f        .  ,"".PublicKey.IsOnCurve   ş,"".PublicKey.ParamsÂ·f        .  &"".PublicKey.Params   ş<"".PublicKey.ScalarBaseMultÂ·f        .  6"".PublicKey.ScalarBaseMult   ş4"".PublicKey.ScalarMultÂ·f        .  ."".PublicKey.ScalarMult   ş6type..hash."".PrivateKeyÂ·f        .  0type..hash."".PrivateKey   ş2type..eq."".PrivateKeyÂ·f        .  ,type..eq."".PrivateKey   ş."".(*PrivateKey).AddÂ·f        .  ("".(*PrivateKey).Add   ş4"".(*PrivateKey).DoubleÂ·f        .  ."".(*PrivateKey).Double   ş:"".(*PrivateKey).IsOnCurveÂ·f        .  4"".(*PrivateKey).IsOnCurve   ş4"".(*PrivateKey).ParamsÂ·f        .  ."".(*PrivateKey).Params   şD"".(*PrivateKey).ScalarBaseMultÂ·f        .  >"".(*PrivateKey).ScalarBaseMult   ş<"".(*PrivateKey).ScalarMultÂ·f        .  6"".(*PrivateKey).ScalarMult   ş("".PrivateKey.AddÂ·f        .  """.PrivateKey.Add   ş."".PrivateKey.DoubleÂ·f        .  ("".PrivateKey.Double   ş4"".PrivateKey.IsOnCurveÂ·f        .  ."".PrivateKey.IsOnCurve   ş."".PrivateKey.ParamsÂ·f        .  ("".PrivateKey.Params   ş>"".PrivateKey.ScalarBaseMultÂ·f        .  8"".PrivateKey.ScalarBaseMult   ş6"".PrivateKey.ScalarMultÂ·f        .  0"".PrivateKey.ScalarMult   ş"runtime.zerovalue      ÿÿgo13ld 